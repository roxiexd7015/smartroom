<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Detalii – {{ sensor|capitalize }}</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body {
      background: #f5f5f5;
      padding: 2rem;
      font-family: Arial, sans-serif;
    }
    .chart-container {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>📊 Evoluție – {{ sensor|capitalize }}</h2>
    <p>Urmărește valorile înregistrate în timp pentru senzorul de <strong>{{ sensor }}</strong>.</p>

    <div class="chart-container my-4">
      <canvas id="sensorChart"></canvas>
    </div>

    <a href="/dashboard" class="btn btn-secondary">← Înapoi la Dashboard</a>
  </div>

<script>
const ctx = document.getElementById('sensorChart').getContext('2d');
const sensor = "{{ sensor }}";

const chart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: [],
    datasets: []
  },
  options: {
    responsive: true,
    animation: false,
    scales: {
      y: {
        beginAtZero: false,
        suggestedMin: 0,  // se va reseta dinamic mai jos
        suggestedMax: 100, // idem
        title: {
          display: true,
          text: sensor === 'temperature' ? '°C' :
                sensor === 'humidity' ? '%' :
                sensor === 'gas' ? 'kΩ' : 'µg/m³'
        }
      },
      x: {
        title: {
          display: true,
          text: 'Ora'
        }
      }
    }
  }
});

let lastValues = [];

async function fetchSensorData() {
  try {
    const res = await fetch(`/api/details/${sensor}`);
    const data = await res.json();

    if (!data || data.length === 0) return;

    const labels = data.map(d => d.timestamp);
    const primary = data.map(d => d.valoare ?? d.brut);
    const secondary = data.map(d => d.medie).filter(v => v !== undefined);

    const hasSecondary = secondary.length > 0;
    const currentValues = hasSecondary ? [...primary, ...secondary] : primary;

    // Comparăm doar valorile brute ca să nu redeseneze fără rost
    if (JSON.stringify(currentValues) !== JSON.stringify(lastValues)) {
      lastValues = currentValues;

      // scalare automată a axei Y
      const minY = Math.min(...primary);
      const maxY = Math.max(...primary);
      const padding = (maxY - minY) * 0.1 || 1;  // dacă diferența e mică, punem 1 ca fallback

      chart.options.scales.y.suggestedMin = minY - padding;
      chart.options.scales.y.suggestedMax = maxY + padding;

      chart.data.labels.splice(0, chart.data.labels.length, ...labels);

        if (hasSecondary) {
        chart.data.datasets[0] = {
            label: "Valori brute",
            data: primary,
            borderColor: sensor === 'dust' ? 'gray' :
                        sensor === 'gas' ? 'green' : 'black', // fallback dacă apare altceva
            backgroundColor: "transparent",
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        chart.data.datasets[1] = {
            label: "Valori medii",
            data: secondary,
            borderColor: "orange",  // 🔸 toate mediile portocalii
            backgroundColor: "transparent",
            borderDash: [5, 5],
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        } else {
        chart.data.datasets[0] = {
            label: "Valoare",
            data: primary,
            borderColor: sensor === 'temperature' ? 'red' :
                        sensor === 'humidity' ? 'blue' :
                        'green', // fallback dacă apare alt senzor
            backgroundColor: "transparent",
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        chart.data.datasets.length = 1;
        }


      chart.update();
    }
  } catch (error) {
    console.error("Eroare la preluarea datelor:", error);
  }
}

setInterval(fetchSensorData, 5000);
fetchSensorData();
</script>
</body>
</html>

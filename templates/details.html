<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Detalii â€“ {{ sensor|capitalize }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

</head>

<body>
  <div class="container">
    <h2>ğŸ“Š EvoluÈ›ie â€“ {{ sensor|capitalize }}</h2>
    <p>UrmÄƒreÈ™te valorile Ã®nregistrate Ã®n timp pentru senzorul de <strong>{{ sensor }}</strong>.</p>

    <div class="chart-container my-4">
      <canvas id="sensorChart"></canvas>
    </div>

    <div class="mb-3">
        <label class="form-label me-2">Interval de timp:</label>
        <div class="btn-group" role="group" aria-label="Interval">
            <button type="button" class="btn btn-outline-primary active" onclick="setRange('latest', this)">Ultimele 50</button>
            <button type="button" class="btn btn-outline-primary" onclick="setRange('hour', this)">Pe ore</button>
            <button type="button" class="btn btn-outline-primary" onclick="setRange('day', this)">Pe zile</button>
            <button type="button" class="btn btn-outline-primary" onclick="setRange('week', this)">Pe sÄƒptÄƒmÃ¢ni</button>
        </div>
    </div>


    <a href="/dashboard" class="btn btn-secondary">â† Ãnapoi la Dashboard</a>
  </div>

<script>
const ctx = document.getElementById('sensorChart').getContext('2d');
const sensor = "{{ sensor }}";

let currentRange = "latest";

let chart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: [],
    datasets: []
  },
  options: {
    responsive: true,
    maintainAspectRatio: false, //sa nu fie prea ingust in varianta mobila
    animation: false,
    scales: {
      y: {
        beginAtZero: false,
        suggestedMin: 0,  // se va reseta dinamic mai jos
        suggestedMax: 100, // idem
        title: {
          display: true,
          text: sensor === 'temperature' ? 'Â°C' :
                sensor === 'humidity' ? '%' :
                sensor === 'gas' ? 'kÎ©' : 'Âµg/mÂ³'
        }
      },
      x: {
        title: {
          display: true,
          text: 'Ora'
        }
      }
    }
  }
});


function setRange(range, btn) {

  currentRange = range;
  document.querySelectorAll(".btn-group .btn").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");
  fetchSensorData();
}

let lastValues = [];

async function fetchSensorData() {
  try {
    const res = await fetch('/api/details/${sensor}?range=${currentRange}');
    const data = await res.json();

    if (!data || data.length === 0) return;

    const labels = data.map(d => d.timestamp || d.x);
    const primary = data.map(d => d.valoare ?? d.brut ?? d.y);
    const secondary = data.map(d => d.medie).filter(v => v !== undefined);

    const hasSecondary = secondary.length > 0;
    const currentValues = hasSecondary ? [...primary, ...secondary] : primary;

    // ComparÄƒm doar valorile brute ca sÄƒ nu redeseneze fÄƒrÄƒ rost
    if (JSON.stringify(currentValues) !== JSON.stringify(lastValues)) {
      lastValues = currentValues;

      // scalare automatÄƒ a axei Y
      const minY = Math.min(...primary);
      const maxY = Math.max(...primary);
      const padding = (maxY - minY) * 0.1 || 1;  // dacÄƒ diferenÈ›a e micÄƒ, punem 1 ca fallback

      chart.options.scales.y.suggestedMin = minY - padding;
      chart.options.scales.y.suggestedMax = maxY + padding;

      chart.data.labels.splice(0, chart.data.labels.length, ...labels);

        if (hasSecondary) {
        chart.data.datasets[0] = {
            label: "Valori brute",
            data: primary,
            borderColor: sensor === 'dust' ? 'gray' :
                        sensor === 'gas' ? 'green' : 'black', // fallback dacÄƒ apare altceva
            backgroundColor: "transparent",
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        chart.data.datasets[1] = {
            label: "Valori medii",
            data: secondary,
            borderColor: "orange",  // ğŸ”¸ toate mediile portocalii
            backgroundColor: "transparent",
            borderDash: [5, 5],
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        } else {
        chart.data.datasets[0] = {
            label: "Valoare",
            data: primary,
            borderColor: sensor === 'temperature' ? 'red' :
                        sensor === 'humidity' ? 'blue' :
                        'green', // fallback dacÄƒ apare alt senzor
            backgroundColor: "transparent",
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        chart.data.datasets.length = 1;
        }


      chart.update();
    }
  } catch (error) {
    console.error("Eroare la preluarea datelor:", error);
  }
}

setInterval(fetchSensorData, 5000);
fetchSensorData();
</script>
</body>
</html>

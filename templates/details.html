<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
    {% set sensor_name = {
    'temperature': 'temperaturÄƒ',
    'humidity': 'umiditate',
    'dust': 'praf',
    'gas': 'gaz'
    } %}
  <title>Detalii â€“ {{ sensor_name[sensor]|capitalize }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

</head>

<body>
  <div class="container">
    <h2>ğŸ“Š EvoluÈ›ie â€“ {{ sensor_name[sensor] | capitalize }}</h2>
    <p>UrmÄƒreÈ™te valorile Ã®nregistrate Ã®n timp pentru senzorul de <strong>{{ sensor_name[sensor] }}</strong>.</p>


    <div class="chart-container my-4">
      <canvas id="sensorChart"></canvas>
    </div>

    <div class="mb-3">
        <label class="form-label me-2">Interval de timp:</label>
        <div class="btn-group" role="group" aria-label="Interval">
            <button type="button" class="btn btn-outline-primary active" onclick="setRange('latest', this)">Ultimele 50</button>
            <button type="button" class="btn btn-outline-primary" onclick="setRange('hour', this)">Pe ore</button>
            <button type="button" class="btn btn-outline-primary" onclick="setRange('day', this)">Pe zile</button>
            <button type="button" class="btn btn-outline-primary" onclick="setRange('week', this)">Pe sÄƒptÄƒmÃ¢ni</button>
        </div>
    </div>

    <div id="chart-summary" class="mt-3 p-3 bg-light rounded shadow-sm">
      <p><strong>ğŸ“Œ Interval:</strong> <span id="interval-label">Ultimele 50 valori</span></p>
      <p><strong>ğŸ”¢ Ultima valoare:</strong> <span id="last-value">-</span></p>
      <p><strong>ğŸ“Š Media:</strong> <span id="average-value">-</span></p>
    </div>

    <div id="sensor-info" class="mt-4">
      {% if sensor == 'temperature' %}
        <p class="text-muted">ğŸŒ¡ï¸ Temperaturile ideale Ã®ntr-un dormitor sunt Ã®ntre <strong>20â€“24â€¯Â°C</strong>. <span class="toggle-info" onclick="toggleExtra()">AflÄƒ mai multe</span></p>
        <div class="extra-info text-muted">
          Aceste temperaturi favorizeazÄƒ somnul odihnitor È™i menÈ›in o stare generalÄƒ de bine, prevenind disconfortul termic.
        </div>
      {% elif sensor == 'humidity' %}
        <p class="text-muted">ğŸ’§ Nivelul optim de umiditate este Ã®ntre <strong>40â€“60%</strong>. <span class="toggle-info" onclick="toggleExtra()">AflÄƒ mai multe</span></p>
        <div class="extra-info text-muted">
          Nivelurile scÄƒzute pot cauza uscÄƒciunea mucoaselor È™i iritaÈ›ii, iar cele ridicate pot favoriza apariÈ›ia mucegaiului.
        </div>
      {% elif sensor == 'dust' %}
        <p class="text-muted">ğŸŒ«ï¸ Particulele de praf peste <strong>150 Âµg/mÂ³</strong> sunt considerate periculoase pentru sÄƒnÄƒtate. <span class="toggle-info" onclick="toggleExtra()">AflÄƒ mai multe</span></p>
            <a href="https://www.who.int/publications/i/item/9789241550376" target="_blank" class="info-icon" title="Ghid OMS privind condiÈ›iile de locuit È™i sÄƒnÄƒtatea">i</a>
            <a href="https://www.airnow.gov/aqi/aqi-basics/" target="_blank" class="info-icon" title="Ghid EPA privind calitatea aerului">i</a>
        <div class="extra-info text-muted">
          Praful poate conÈ›ine alergeni, bacterii È™i particule fine care afecteazÄƒ sistemul respirator, mai ales la copii È™i vÃ¢rstnici. Valorile Ã®ntre 12â€“35 Âµg/mÂ³ sunt considerate moderate. DacÄƒ sunt Ã®ntre 50â€“150â€¯Âµg/mÂ³, pot afecta persoanele sensibile. Peste 150, aerul este nesÄƒnÄƒtos pentru toatÄƒ lumea. Nivelurile mari pot apÄƒrea din cauza prafului acumulat pe mobilier, circulaÈ›iei aerului sau ventilaÈ›iei slabe.
        </div>
      {% elif sensor == 'gas' %}
        <p class="text-muted">ğŸ§ª RezistenÈ›a gazului sub <strong>10â€¯kÎ©</strong> poate indica un nivel slab al calitÄƒÈ›ii aerului. <span class="toggle-info" onclick="toggleExtra()">AflÄƒ mai multe</span></p>
        <div class="extra-info text-muted">
          Valorile mici pot semnala prezenÈ›a compuÈ™ilor organici volatili (VOC) eliberaÈ›i de produse de curÄƒÈ›enie, mobilier sau plastic.
        </div>
      {% endif %}
    </div>
    <a href="/dashboard" class="btn btn-secondary">â† Ãnapoi la Dashboard</a>
  </div>

<script>
const ctx = document.getElementById('sensorChart').getContext('2d');
const sensor = "{{ sensor }}";

let currentRange = "latest";

let chart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: [],
    datasets: []
  },
  options: {
    responsive: true,
    maintainAspectRatio: false, //sa nu fie prea ingust in varianta mobila
    animation: false,
    scales: {
      y: {
        beginAtZero: false,
        suggestedMin: 0,  // se va reseta dinamic mai jos
        suggestedMax: 100, // idem
        title: {
          display: true,
          text: sensor === 'temperature' ? 'Â°C' :
                sensor === 'humidity' ? '%' :
                sensor === 'gas' ? 'kÎ©' : 'Âµg/mÂ³'
        }
      },
      x: {
        title: {
          display: true,
          text: 'Ora'
        }
      }
    }
  }
});


function setRange(range, btn) {

  currentRange = range;
  document.querySelectorAll(".btn-group .btn").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");
  fetchSensorData();
}

let lastValues = [];

async function fetchSensorData() {
  try {
    const res = await fetch(`/api/details/${sensor}?range=${currentRange}`);
    const data = await res.json();

    if (!data || data.length === 0) return;

    const labels = data.map(d => d.timestamp || d.x);
    const primary = data.map(d => d.valoare ?? d.brut ?? d.y);
    const secondary = data.map(d => d.medie).filter(v => v !== undefined);

    const hasSecondary = secondary.length > 0;
    const currentValues = hasSecondary ? [...primary, ...secondary] : primary;

    // ComparÄƒm doar valorile brute ca sÄƒ nu redeseneze fÄƒrÄƒ rost
    if (JSON.stringify(currentValues) !== JSON.stringify(lastValues)) {
      lastValues = currentValues;

      // scalare automatÄƒ a axei Y
      const minY = Math.min(...primary);
      const maxY = Math.max(...primary);
      const padding = (maxY - minY) * 0.1 || 1;  // dacÄƒ diferenÈ›a e micÄƒ, punem 1 ca fallback

      chart.options.scales.y.suggestedMin = minY - padding;
      chart.options.scales.y.suggestedMax = maxY + padding;

      chart.data.labels.splice(0, chart.data.labels.length, ...labels);

        if (hasSecondary) {
        chart.data.datasets[0] = {
            label: "Valori brute",
            data: primary,
            borderColor: sensor === 'dust' ? 'gray' :
                        sensor === 'gas' ? 'green' : 'black', // fallback dacÄƒ apare altceva
            backgroundColor: "transparent",
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        chart.data.datasets[1] = {
            label: "Valori medii",
            data: secondary,
            borderColor: "orange",  // ğŸ”¸ toate mediile portocalii
            backgroundColor: "transparent",
            borderDash: [5, 5],
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        } else {
        chart.data.datasets[0] = {
            label: "Valoare",
            data: primary,
            borderColor: sensor === 'temperature' ? 'red' :
                        sensor === 'humidity' ? 'blue' :
                        'green', // fallback dacÄƒ apare alt senzor
            backgroundColor: "transparent",
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 4
        };
        chart.data.datasets.length = 1;
        }


      chart.update();
    }
  } catch (error) {
    console.error("Eroare la preluarea datelor:", error);
  }
}

setInterval(fetchSensorData, 5000);
fetchSensorData();
</script>
</body>
</html>
